import{V as t,au as s,ao as e,m as r,o as i,$ as n,a7 as o,k as a,ad as h,ak as c,bG as u,bF as d,bH as p,bZ as l,b_ as k,b$ as f,c0 as m,c1 as b,c2 as g,c3 as w,bC as v,c4 as E,c5 as y}from"./main.js";import{v as S,b as C}from"./fen-f2d95e2d.js";import{p as q}from"./layout-b3635a82.js";var P={controller(){let t=!1;const s=o(null),e=o("standard"),r=o("white");function i(s){"backbutton"!==s&&t&&a.backbutton.stack.pop(),t=!1}return{open:function(n,o,h="white"){a.backbutton.stack.push(i),s(n),e(o),r(h),t=!0},close:i,fen:s,variant:e,color:r,isOpen:function(){return t}}},view:o=>t("continueFromHere",(()=>r("h2",i("continueFromHere"))),(()=>[!s.has(o.variant())&&e()?r("p.sep",i("playOnline")):null,!s.has(o.variant())&&e()?r("button",{oncreate:n((()=>{o.close();const t=o.fen();t&&q.openAIFromPosition(t)}))},i("playWithTheMachine")):null,!s.has(o.variant())&&e()?r("button",{oncreate:n((()=>{o.close();const t=o.fen();t&&h.openFromPosition(t)}))},i("playWithAFriend")):null,r("p.sep",i("playOffline")),r("button",{oncreate:n((()=>{o.close();const t=o.fen(),s=o.variant(),e=o.color();t&&(S(t,s)&&C(t)?a.set(`/ai/variant/${s}/fen/${encodeURIComponent(t)}/color/${e}`):c.show({text:"Invalid FEN",position:"center",duration:"short"}))}))},i("computer")),r("button",{oncreate:n((()=>{o.close();const t=o.fen(),s=o.variant();t&&(S(t,s)&&C(t)?a.set(`/otb/variant/${s}/fen/${encodeURIComponent(t)}`):c.show({text:"Invalid FEN",position:"center",duration:"short"}))}))},i("overTheBoard"))]),o.isOpen(),o.close)};function R(t,s){let e=u.empty();for(const r of s){const s=t+r;0<=s&&s<64&&Math.abs(d(t)-d(s))<=2&&(e=e.with(s))}return e}function O(t){const s=[];for(let e=0;e<64;e++)s[e]=t(e);return s}const A=O((t=>R(t,[-9,-8,-7,-1,1,7,8,9]))),x=O((t=>R(t,[-17,-15,-10,-6,6,10,15,17]))),I={white:O((t=>R(t,[7,9]))),black:O((t=>R(t,[-7,-9])))};function M(t){return A[t]}function D(t){return x[t]}function K(t,s){return I[t][s]}const V=O((t=>u.fromFile(d(t)).without(t))),z=O((t=>u.fromRank(p(t)).without(t))),_=O((t=>{const s=new u(134480385,2151686160),e=8*(p(t)-d(t));return(e>=0?s.shl64(e):s.shr64(-e)).without(t)})),F=O((t=>{const s=new u(270549120,16909320),e=8*(p(t)+d(t)-7);return(e>=0?s.shl64(e):s.shr64(-e)).without(t)}));function T(t,s,e){let r=e.intersect(s),i=r.bswap64();return r=r.minus64(t),i=i.minus64(t.bswap64()),r.xor(i.bswap64()).intersect(s)}function H(t,s){const e=u.fromSquare(t);return T(e,_[t],s).xor(T(e,F[t],s))}function B(t,s){return function(t,s){return T(u.fromSquare(t),V[t],s)}(t,s).xor(function(t,s){const e=z[t];let r=s.intersect(e),i=r.rbit64();return r=r.minus64(u.fromSquare(t)),i=i.minus64(u.fromSquare(63-t)),r.xor(i.rbit64()).intersect(e)}(t,s))}function N(t,s){return H(t,s).xor(B(t,s))}function $(t,s){const e=u.fromSquare(s);return z[t].intersects(e)?z[t].with(t):F[t].intersects(e)?F[t].with(t):_[t].intersects(e)?_[t].with(t):V[t].intersects(e)?V[t].with(t):u.empty()}function Q(t,s){return $(t,s).intersect(u.full().shl64(t).xor(u.full().shl64(s))).withoutFirst()}var j;!function(t){t.Empty="ERR_EMPTY",t.OppositeCheck="ERR_OPPOSITE_CHECK",t.ImpossibleCheck="ERR_IMPOSSIBLE_CHECK",t.PawnsOnBackrank="ERR_PAWNS_ON_BACKRANK",t.Kings="ERR_KINGS",t.Variant="ERR_VARIANT"}(j||(j={}));class PositionError extends Error{}function W(t,s){return"white"===t?"a"===s?3:5:"a"===s?59:61}class Castles{constructor(){}static default(){const t=new Castles;return t.unmovedRooks=u.corners(),t.rook={white:{a:0,h:7},black:{a:56,h:63}},t.path={white:{a:new u(14,0),h:new u(96,0)},black:{a:new u(0,234881024),h:new u(0,1610612736)}},t}static empty(){const t=new Castles;return t.unmovedRooks=u.empty(),t.rook={white:{a:void 0,h:void 0},black:{a:void 0,h:void 0}},t.path={white:{a:u.empty(),h:u.empty()},black:{a:u.empty(),h:u.empty()}},t}clone(){const t=new Castles;return t.unmovedRooks=this.unmovedRooks,t.rook={white:{a:this.rook.white.a,h:this.rook.white.h},black:{a:this.rook.black.a,h:this.rook.black.h}},t.path={white:{a:this.path.white.a,h:this.path.white.h},black:{a:this.path.black.a,h:this.path.black.h}},t}add(t,s,e,r){const i=w(t,s),n=W(t,s);this.unmovedRooks=this.unmovedRooks.with(r),this.rook[t][s]=r,this.path[t][s]=Q(r,n).with(n).union(Q(e,i).with(i)).without(e).without(r)}static fromSetup(t){const s=Castles.empty(),e=t.unmovedRooks.intersect(t.board.rook);for(const r of l){const i=u.backrank(r),n=t.board.kingOf(r);if(!k(n)||!i.has(n))continue;const o=e.intersect(t.board[r]).intersect(i),a=o.first();k(a)&&a<n&&s.add(r,"a",n,a);const h=o.last();k(h)&&n<h&&s.add(r,"h",n,h)}return s}discardRook(t){if(this.unmovedRooks.has(t)){this.unmovedRooks=this.unmovedRooks.without(t);for(const s of l)for(const e of f)this.rook[s][e]===t&&(this.rook[s][e]=void 0)}}discardSide(t){this.unmovedRooks=this.unmovedRooks.diff(u.backrank(t)),this.rook[t].a=void 0,this.rook[t].h=void 0}}class Position{constructor(t){this.rules=t}kingAttackers(t,s,e){return function(t,s,e,r){return e[s].intersect(B(t,r).intersect(e.rooksAndQueens()).union(H(t,r).intersect(e.bishopsAndQueens())).union(D(t).intersect(e.knight)).union(M(t).intersect(e.king)).union(K(g(s),t).intersect(e.pawn)))}(t,s,this.board,e)}dropDests(t){return u.empty()}playCaptureAt(t,s){this.halfmoves=0,"rook"===s.role&&this.castles.discardRook(t),this.pockets&&this.pockets[g(s.color)][s.role]++}ctx(){const t=this.isVariantEnd(),s=this.board.kingOf(this.turn);if(!k(s))return{king:s,blockers:u.empty(),checkers:u.empty(),variantEnd:t,mustCapture:!1};const e=B(s,u.empty()).intersect(this.board.rooksAndQueens()).union(H(s,u.empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[g(this.turn)]);let r=u.empty();for(const t of e){const e=Q(s,t).intersect(this.board.occupied);e.moreThanOne()||(r=r.union(e))}return{king:s,blockers:r,checkers:this.kingAttackers(s,g(this.turn),this.board.occupied),variantEnd:t,mustCapture:!1}}clone(){var t,s;const e=new this.constructor;return e.board=this.board.clone(),e.pockets=null===(t=this.pockets)||void 0===t?void 0:t.clone(),e.turn=this.turn,e.castles=this.castles.clone(),e.epSquare=this.epSquare,e.remainingChecks=null===(s=this.remainingChecks)||void 0===s?void 0:s.clone(),e.halfmoves=this.halfmoves,e.fullmoves=this.fullmoves,e}equalsIgnoreMoves(t){var s,e;return this.rules===t.rules&&(this.pockets?this.board.equals(t.board):this.board.equalsIgnorePromoted(t.board))&&(t.pockets&&(null===(s=this.pockets)||void 0===s?void 0:s.equals(t.pockets))||!this.pockets&&!t.pockets)&&this.turn===t.turn&&this.castles.unmovedRooks.equals(t.castles.unmovedRooks)&&this.legalEpSquare()===t.legalEpSquare()&&(t.remainingChecks&&(null===(e=this.remainingChecks)||void 0===e?void 0:e.equals(t.remainingChecks))||!this.remainingChecks&&!t.remainingChecks)}toSetup(){var t,s;return{board:this.board.clone(),pockets:null===(t=this.pockets)||void 0===t?void 0:t.clone(),turn:this.turn,unmovedRooks:this.castles.unmovedRooks,epSquare:this.legalEpSquare(),remainingChecks:null===(s=this.remainingChecks)||void 0===s?void 0:s.clone(),halfmoves:Math.min(this.halfmoves,150),fullmoves:Math.min(Math.max(this.fullmoves,1),9999)}}isInsufficientMaterial(){return l.every((t=>this.hasInsufficientMaterial(t)))}hasDests(t){t=t||this.ctx();for(const s of this.board[this.turn])if(this.dests(s,t).nonEmpty())return!0;return this.dropDests(t).nonEmpty()}isLegal(t,s){if(v(t))return!(!this.pockets||this.pockets[this.turn][t.role]<=0)&&(("pawn"!==t.role||!u.backranks().has(t.to))&&this.dropDests(s).has(t.to));{if("pawn"===t.promotion)return!1;if("king"===t.promotion&&"antichess"!==this.rules)return!1;if(!!t.promotion!==(this.board.pawn.has(t.from)&&u.backranks().has(t.to)))return!1;const e=this.dests(t.from,s);return e.has(t.to)||e.has(this.normalizeMove(t).to)}}isCheck(){const t=this.board.kingOf(this.turn);return k(t)&&this.kingAttackers(t,g(this.turn),this.board.occupied).nonEmpty()}isEnd(t){return!!(t?t.variantEnd:this.isVariantEnd())||(this.isInsufficientMaterial()||!this.hasDests(t))}isCheckmate(t){return!(t=t||this.ctx()).variantEnd&&t.checkers.nonEmpty()&&!this.hasDests(t)}isStalemate(t){return!(t=t||this.ctx()).variantEnd&&t.checkers.isEmpty()&&!this.hasDests(t)}outcome(t){const s=this.variantOutcome(t);return s||(t=t||this.ctx(),this.isCheckmate(t)?{winner:g(this.turn)}:this.isInsufficientMaterial()||this.isStalemate(t)?{winner:void 0}:void 0)}allDests(t){t=t||this.ctx();const s=new Map;if(t.variantEnd)return s;for(const e of this.board[this.turn])s.set(e,this.dests(e,t));return s}castlingSide(t){if(v(t))return;const s=t.to-t.from;return(2===Math.abs(s)||this.board[this.turn].has(t.to))&&this.board.king.has(t.from)?s>0?"h":"a":void 0}normalizeMove(t){const s=this.castlingSide(t);if(!s)return t;const e=this.castles.rook[this.turn][s];return{from:t.from,to:k(e)?e:t.to}}play(t){const s=this.turn,e=this.epSquare,r=this.castlingSide(t);if(this.epSquare=void 0,this.halfmoves+=1,"black"===s&&(this.fullmoves+=1),this.turn=g(s),v(t))this.board.set(t.to,{role:t.role,color:s}),this.pockets&&this.pockets[s][t.role]--,"pawn"===t.role&&(this.halfmoves=0);else{const i=this.board.take(t.from);if(!i)return;let n;if("pawn"===i.role){this.halfmoves=0,t.to===e&&(n=this.board.take(t.to+("white"===s?-8:8)));const r=t.from-t.to;16===Math.abs(r)&&8<=t.from&&t.from<=55&&(this.epSquare=t.from+t.to>>1),t.promotion&&(i.role=t.promotion,i.promoted=!0)}else if("rook"===i.role)this.castles.discardRook(t.from);else if("king"===i.role){if(r){const t=this.castles.rook[s][r];if(k(t)){const e=this.board.take(t);this.board.set(w(s,r),i),e&&this.board.set(W(s,r),e)}}this.castles.discardSide(s)}if(!r){const s=this.board.set(t.to,i)||n;s&&this.playCaptureAt(t.to,s)}}this.remainingChecks&&this.isCheck()&&(this.remainingChecks[s]=Math.max(this.remainingChecks[s]-1,0))}legalEpSquare(t){if(!k(this.epSquare))return;t=t||this.ctx();const s=this.board.pieces(this.turn,"pawn").intersect(K(g(this.turn),this.epSquare));for(const e of s)if(this.dests(e,t).has(this.epSquare))return this.epSquare}}class Chess extends Position{constructor(t){super(t||"chess")}static default(){const t=new this;return t.board=m.default(),t.pockets=void 0,t.turn="white",t.castles=Castles.default(),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){const s=new this;return s.board=t.board.clone(),s.pockets=void 0,s.turn=t.turn,s.castles=Castles.fromSetup(t),s.epSquare=s.validEpSquare(t.epSquare),s.remainingChecks=void 0,s.halfmoves=t.halfmoves,s.fullmoves=t.fullmoves,s.validate().map((t=>s))}clone(){return super.clone()}validate(){if(this.board.occupied.isEmpty())return b.err(new PositionError(j.Empty));if(2!==this.board.king.size())return b.err(new PositionError(j.Kings));if(!k(this.board.kingOf(this.turn)))return b.err(new PositionError(j.Kings));const t=this.board.kingOf(g(this.turn));return k(t)?this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty()?b.err(new PositionError(j.OppositeCheck)):u.backranks().intersects(this.board.pawn)?b.err(new PositionError(j.PawnsOnBackrank)):this.validateCheckers():b.err(new PositionError(j.Kings))}validateCheckers(){const t=this.board.kingOf(this.turn);if(k(t)){const s=this.kingAttackers(t,g(this.turn),this.board.occupied);if(s.size()>2||2===s.size()&&$(s.first(),s.last()).has(t))return b.err(new PositionError(j.ImpossibleCheck));if(k(this.epSquare))for(const e of s)if($(e,this.epSquare).has(t))return b.err(new PositionError(j.ImpossibleCheck))}return b.ok(void 0)}validEpSquare(t){if(!k(t))return;const s="white"===this.turn?5:2,e="white"===this.turn?8:-8;if(p(t)!==s)return;if(this.board.occupied.has(t+e))return;const r=t-e;return this.board.pawn.has(r)&&this.board[g(this.turn)].has(r)?t:void 0}castlingDest(t,s){if(!k(s.king)||s.checkers.nonEmpty())return u.empty();const e=this.castles.rook[this.turn][t];if(!k(e))return u.empty();if(this.castles.path[this.turn][t].intersects(this.board.occupied))return u.empty();const r=w(this.turn,t),i=Q(s.king,r),n=this.board.occupied.without(s.king);for(const t of i)if(this.kingAttackers(t,g(this.turn),n).nonEmpty())return u.empty();const o=W(this.turn,t),a=this.board.occupied.toggle(s.king).toggle(e).toggle(o);return this.kingAttackers(r,g(this.turn),a).nonEmpty()?u.empty():u.fromSquare(e)}canCaptureEp(t,s){if(!k(this.epSquare))return!1;if(!K(this.turn,t).has(this.epSquare))return!1;if(!k(s.king))return!0;const e=this.epSquare+("white"===this.turn?-8:8),r=this.board.occupied.toggle(t).toggle(this.epSquare).toggle(e);return!this.kingAttackers(s.king,g(this.turn),r).intersects(r)}pseudoDests(t,s){if(s.variantEnd)return u.empty();const e=this.board.get(t);if(!e||e.color!==this.turn)return u.empty();let r=function(t,s,e){switch(t.role){case"pawn":return K(t.color,s);case"knight":return D(s);case"bishop":return H(s,e);case"rook":return B(s,e);case"queen":return N(s,e);case"king":return M(s)}}(e,t,this.board.occupied);if("pawn"===e.role){let s=this.board[g(this.turn)];k(this.epSquare)&&(s=s.with(this.epSquare)),r=r.intersect(s);const e="white"===this.turn?8:-8,i=t+e;if(0<=i&&i<64&&!this.board.occupied.has(i)){r=r.with(i);const s=i+e;("white"===this.turn?t<16:t>=48)&&!this.board.occupied.has(s)&&(r=r.with(s))}return r}return r=r.diff(this.board[this.turn]),t===s.king?r.union(this.castlingDest("a",s)).union(this.castlingDest("h",s)):r}dests(t,s){if((s=s||this.ctx()).variantEnd)return u.empty();const e=this.board.get(t);if(!e||e.color!==this.turn)return u.empty();let r,i;if("pawn"===e.role){r=K(this.turn,t).intersect(this.board[g(this.turn)]);const e="white"===this.turn?8:-8,n=t+e;if(0<=n&&n<64&&!this.board.occupied.has(n)){r=r.with(n);const s=n+e;("white"===this.turn?t<16:t>=48)&&!this.board.occupied.has(s)&&(r=r.with(s))}if(k(this.epSquare)&&this.canCaptureEp(t,s)){const t=this.epSquare-e;(s.checkers.isEmpty()||s.checkers.singleSquare()===t)&&(i=u.fromSquare(this.epSquare))}}else r="bishop"===e.role?H(t,this.board.occupied):"knight"===e.role?D(t):"rook"===e.role?B(t,this.board.occupied):"queen"===e.role?N(t,this.board.occupied):M(t);if(r=r.diff(this.board[this.turn]),k(s.king)){if("king"===e.role){const e=this.board.occupied.without(t);for(const t of r)this.kingAttackers(t,g(this.turn),e).nonEmpty()&&(r=r.without(t));return r.union(this.castlingDest("a",s)).union(this.castlingDest("h",s))}if(s.checkers.nonEmpty()){const t=s.checkers.singleSquare();if(!k(t))return u.empty();r=r.intersect(Q(t,s.king).with(t))}s.blockers.has(t)&&(r=r.intersect($(t,s.king)))}return i&&(r=r.union(i)),r}isVariantEnd(){return!1}variantOutcome(t){}hasInsufficientMaterial(t){if(this.board[t].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())return!1;if(this.board[t].intersects(this.board.knight))return this.board[t].size()<=2&&this.board[g(t)].diff(this.board.king).diff(this.board.queen).isEmpty();if(this.board[t].intersects(this.board.bishop)){return(!this.board.bishop.intersects(u.darkSquares())||!this.board.bishop.intersects(u.lightSquares()))&&this.board.pawn.isEmpty()&&this.board.knight.isEmpty()}return!0}}class Crazyhouse extends Chess{constructor(){super("crazyhouse")}static default(){const t=super.default();return t.pockets=E.empty(),t}static fromSetup(t){return super.fromSetup(t).map((s=>(s.pockets=t.pockets?t.pockets.clone():E.empty(),s)))}validate(){return super.validate().chain((t=>this.pockets&&(this.pockets.white.king>0||this.pockets.black.king>0)?b.err(new PositionError(j.Kings)):(this.pockets?this.pockets.count():0)+this.board.occupied.size()>64?b.err(new PositionError(j.Variant)):b.ok(void 0)))}clone(){return super.clone()}hasInsufficientMaterial(t){return this.pockets?this.board.occupied.size()+this.pockets.count()<=3&&this.board.pawn.isEmpty()&&this.board.promoted.isEmpty()&&this.board.rooksAndQueens().isEmpty()&&this.pockets.white.pawn<=0&&this.pockets.black.pawn<=0&&this.pockets.white.rook<=0&&this.pockets.black.rook<=0&&this.pockets.white.queen<=0&&this.pockets.black.queen<=0:super.hasInsufficientMaterial(t)}dropDests(t){var s,e;const r=this.board.occupied.complement().intersect((null===(s=this.pockets)||void 0===s?void 0:s[this.turn].hasNonPawns())?u.full():(null===(e=this.pockets)||void 0===e?void 0:e[this.turn].hasPawns())?u.backranks().complement():u.empty());if(t=t||this.ctx(),k(t.king)&&t.checkers.nonEmpty()){const s=t.checkers.singleSquare();return k(s)?r.intersect(Q(s,t.king)):u.empty()}return r}}class Atomic extends Chess{constructor(){super("atomic")}static default(){return super.default()}static fromSetup(t){return super.fromSetup(t)}clone(){return super.clone()}validate(){if(this.board.occupied.isEmpty())return b.err(new PositionError(j.Empty));if(this.board.king.size()>2)return b.err(new PositionError(j.Kings));const t=this.board.kingOf(g(this.turn));return k(t)?this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty()?b.err(new PositionError(j.OppositeCheck)):u.backranks().intersects(this.board.pawn)?b.err(new PositionError(j.PawnsOnBackrank)):b.ok(void 0):b.err(new PositionError(j.Kings))}kingAttackers(t,s,e){const r=this.board.pieces(s,"king");return r.isEmpty()||M(t).intersects(r)?u.empty():super.kingAttackers(t,s,e)}playCaptureAt(t,s){super.playCaptureAt(t,s),this.board.take(t);for(const s of M(t).intersect(this.board.occupied).diff(this.board.pawn)){const t=this.board.take(s);t&&"rook"===t.role&&this.castles.discardRook(s),t&&"king"===t.role&&this.castles.discardSide(t.color)}}hasInsufficientMaterial(t){if(this.board.pieces(g(t),"king").isEmpty())return!1;if(this.board[t].diff(this.board.king).isEmpty())return!0;if(this.board[g(t)].diff(this.board.king).nonEmpty()){if(this.board.occupied.equals(this.board.bishop.union(this.board.king))){if(!this.board.bishop.intersect(this.board.white).intersects(u.darkSquares()))return!this.board.bishop.intersect(this.board.black).intersects(u.lightSquares());if(!this.board.bishop.intersect(this.board.white).intersects(u.lightSquares()))return!this.board.bishop.intersect(this.board.black).intersects(u.darkSquares())}return!1}return!this.board.queen.nonEmpty()&&!this.board.pawn.nonEmpty()&&(!!this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare()||!!this.board.occupied.equals(this.board.knight.union(this.board.king))&&this.board.knight.size()<=2)}dests(t,s){s=s||this.ctx();let e=u.empty();for(const r of this.pseudoDests(t,s)){const s=this.clone();s.play({from:t,to:r});const i=s.board.kingOf(this.turn);!k(i)||k(s.board.kingOf(s.turn))&&!s.kingAttackers(i,s.turn,s.board.occupied).isEmpty()||(e=e.with(r))}return e}isVariantEnd(){return!!this.variantOutcome()}variantOutcome(t){for(const t of l)if(this.board.pieces(t,"king").isEmpty())return{winner:g(t)}}}class Antichess extends Chess{constructor(){super("antichess")}static default(){const t=super.default();return t.castles=Castles.empty(),t}static fromSetup(t){return super.fromSetup(t).map((t=>(t.castles=Castles.empty(),t)))}clone(){return super.clone()}validate(){return this.board.occupied.isEmpty()?b.err(new PositionError(j.Empty)):u.backranks().intersects(this.board.pawn)?b.err(new PositionError(j.PawnsOnBackrank)):b.ok(void 0)}kingAttackers(t,s,e){return u.empty()}ctx(){const t=super.ctx(),s=this.board[g(this.turn)];for(const e of this.board[this.turn])if(this.pseudoDests(e,t).intersects(s)){t.mustCapture=!0;break}return t}dests(t,s){s=s||this.ctx();const e=this.pseudoDests(t,s);return s.mustCapture?e.intersect(this.board[g(this.turn)]):e}hasInsufficientMaterial(t){if(this.board.occupied.equals(this.board.bishop)){const s=this.board[t].intersects(u.lightSquares()),e=this.board[t].intersects(u.darkSquares()),r=this.board[g(t)].isDisjoint(u.lightSquares()),i=this.board[g(t)].isDisjoint(u.darkSquares());return s&&r||e&&i}return!1}isVariantEnd(){return this.board[this.turn].isEmpty()}variantOutcome(t){if((t=t||this.ctx()).variantEnd||this.isStalemate(t))return{winner:this.turn}}}class KingOfTheHill extends Chess{constructor(){super("kingofthehill")}static default(){return super.default()}static fromSetup(t){return super.fromSetup(t)}clone(){return super.clone()}hasInsufficientMaterial(t){return!1}isVariantEnd(){return this.board.king.intersects(u.center())}variantOutcome(t){for(const t of l)if(this.board.pieces(t,"king").intersects(u.center()))return{winner:t}}}class ThreeCheck extends Chess{constructor(){super("3check")}static default(){const t=super.default();return t.remainingChecks=y.default(),t}static fromSetup(t){return super.fromSetup(t).map((s=>(s.remainingChecks=t.remainingChecks?t.remainingChecks.clone():y.default(),s)))}clone(){return super.clone()}hasInsufficientMaterial(t){return this.board.pieces(t,"king").equals(this.board[t])}isVariantEnd(){return!!this.remainingChecks&&(this.remainingChecks.white<=0||this.remainingChecks.black<=0)}variantOutcome(t){if(this.remainingChecks)for(const t of l)if(this.remainingChecks[t]<=0)return{winner:t}}}class RacingKings extends Chess{constructor(){super("racingkings")}static default(){const t=new this;return t.board=m.racingKings(),t.pockets=void 0,t.turn="white",t.castles=Castles.empty(),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){return super.fromSetup(t).map((t=>(t.castles=Castles.empty(),t)))}validate(){return this.isCheck()?b.err(new PositionError(j.ImpossibleCheck)):this.board.pawn.nonEmpty()?b.err(new PositionError(j.Variant)):super.validate()}clone(){return super.clone()}dests(t,s){if(t===(s=s||this.ctx()).king)return super.dests(t,s);let e=u.empty();for(const r of super.dests(t,s)){const s={from:t,to:r},i=this.clone();i.play(s),i.isCheck()||(e=e.with(r))}return e}hasInsufficientMaterial(t){return!1}isVariantEnd(){const t=u.fromRank(7),s=this.board.king.intersect(t);if(s.isEmpty())return!1;if("white"===this.turn||s.intersects(this.board.black))return!0;const e=this.board.kingOf("black");if(k(e)){const s=this.board.occupied.without(e);for(const r of M(e).intersect(t).diff(this.board.black))if(this.kingAttackers(r,"white",s).isEmpty())return!1}return!0}variantOutcome(t){if(t?!t.variantEnd:!this.isVariantEnd())return;const s=u.fromRank(7),e=this.board.pieces("black","king").intersects(s),r=this.board.pieces("white","king").intersects(s);return e&&!r?{winner:"black"}:r&&!e?{winner:"white"}:{winner:void 0}}}class Horde extends Chess{constructor(){super("horde")}static default(){const t=new this;return t.board=m.horde(),t.pockets=void 0,t.turn="white",t.castles=Castles.default(),t.castles.discardSide("white"),t.epSquare=void 0,t.remainingChecks=void 0,t.halfmoves=0,t.fullmoves=1,t}static fromSetup(t){return super.fromSetup(t)}validate(){if(this.board.occupied.isEmpty())return b.err(new PositionError(j.Empty));if(!this.board.king.isSingleSquare())return b.err(new PositionError(j.Kings));if(!this.board.king.diff(this.board.promoted).isSingleSquare())return b.err(new PositionError(j.Kings));const t=this.board.kingOf(g(this.turn));if(k(t)&&this.kingAttackers(t,this.turn,this.board.occupied).nonEmpty())return b.err(new PositionError(j.OppositeCheck));for(const t of l)if(this.board.pieces(t,"pawn").intersects(u.backrank(g(t))))return b.err(new PositionError(j.PawnsOnBackrank));return this.validateCheckers()}clone(){return super.clone()}hasInsufficientMaterial(t){return!1}isVariantEnd(){return this.board.white.isEmpty()||this.board.black.isEmpty()}variantOutcome(t){return this.board.white.isEmpty()?{winner:"black"}:this.board.black.isEmpty()?{winner:"white"}:void 0}}function G(t,s){switch(t){case"chess":return Chess.fromSetup(s);case"antichess":return Antichess.fromSetup(s);case"atomic":return Atomic.fromSetup(s);case"horde":return Horde.fromSetup(s);case"racingkings":return RacingKings.fromSetup(s);case"kingofthehill":return KingOfTheHill.fromSetup(s);case"3check":return ThreeCheck.fromSetup(s);case"crazyhouse":return Crazyhouse.fromSetup(s)}}export{Castles as C,D as a,H as b,P as c,M as k,N as q,B as r,G as s};
