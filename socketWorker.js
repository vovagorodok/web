!function(){"use strict";class StrongSocket{constructor(e,t,s,n,i,o){this.ctx=e,this.baseUrl=s,this.path=n,this.ackable=new Ackable(((e,t,s)=>this.send(e,t,s))),this.lastPingTime=performance.now(),this.pongCount=0,this.averageLag=0,this.autoReconnect=!0,this.connect=()=>{this.disconnect(),this.autoReconnect=!0;const e=function(e,t){const s=new URLSearchParams;for(const e of Object.keys(t))void 0!==t[e]&&s.append(e,t[e]);const n=s.toString();return n?`${e}?${n}`:e}(this.baseUrl+this.path,Object.assign(Object.assign({},this.settings.params),{v:this.version}));this.debug("connection attempt to "+e);try{const t=this.ws=new WebSocket(e);t.onerror=e=>this.onError(e),t.onclose=()=>{this.debug("connection closed"),this.ctx.postMessage({topic:"disconnected"}),this.autoReconnect&&(this.debug("Will autoreconnect in "+this.options.autoReconnectDelay),this.scheduleConnect(this.options.autoReconnectDelay))},t.onopen=()=>{this.debug("connected to "+e),this.ctx.postMessage({topic:"onOpen"}),this.options.sendOnOpen&&this.options.sendOnOpen.forEach((e=>{this.send(e.t,e.d)})),this.onSuccess(),this.pingNow(),this.ackable.resend()},t.onmessage=e=>{if("0"===e.data)return this.pong();const t=JSON.parse(e.data);"n"===t.t&&this.pong(),this.handle(t)}}catch(e){this.onError(e)}this.scheduleConnect(this.options.pingMaxLag)},this.schedulePing=e=>{clearTimeout(this.pingSchedule),this.pingSchedule=setTimeout(this.pingNow,e)},this.pingNow=()=>{clearTimeout(this.pingSchedule),clearTimeout(this.connectSchedule);const e=this.options.isAuth&&this.pongCount%8==2?JSON.stringify({t:"p",l:Math.round(.1*this.averageLag)}):"null";try{this.ws.send(e),this.lastPingTime=performance.now()}catch(e){this.debug(e,!0)}this.scheduleConnect(this.options.pingMaxLag)},this.computePingDelay=()=>this.options.pingDelay+(this.options.idle?1e3:0),this.pong=()=>{clearTimeout(this.connectSchedule),this.schedulePing(this.computePingDelay());const e=Math.min(performance.now()-this.lastPingTime,1e4);this.pongCount++;const t=this.pongCount>4?.1:1/this.pongCount;this.averageLag+=t*(e-this.averageLag),this.ctx.postMessage({topic:"pingInterval",payload:this.pingInterval()})},this.disconnect=e=>{clearTimeout(this.pingSchedule),clearTimeout(this.connectSchedule);const t=this.ws;t&&(this.debug("Disconnect",!0),this.autoReconnect=!1,t.onerror=t.onclose=t.onopen=t.onmessage=()=>{},t.close(),e&&setTimeout(e,0))},this.onError=e=>{this.ctx.postMessage({topic:"onError"}),this.ctx.postMessage({topic:"disconnected"}),this.options.debug=!0,this.debug("error: "+JSON.stringify(e)),clearTimeout(this.pingSchedule)},this.onSuccess=()=>{this.ctx.postMessage({topic:"connected"})},this.version=i,this.settings={receive:o.receive,events:o.events||{},params:Object.assign(Object.assign({},o.params||{}),{mobile:1,sri:t})},this.options=Object.assign(Object.assign({},StrongSocket.defaultOptions),o.options||{}),this.debug("Debug is enabled"),this.connect()}send(e,t,s={},n=!1){const i={t:e};void 0!==t&&(s.withLag&&(t.l=Math.round(this.averageLag)),s.millis>=0&&(t.s=Math.round(.1*s.millis).toString(36)),s.blur&&(t.b=1),i.d=t),s.ackable&&(i.d=i.d||{},this.ackable.register(e,i.d));const o=JSON.stringify(i);this.debug("send "+o);try{this.ws.send(o)}catch(t){n||setTimeout((()=>this.send(e,i.d,s,!0)),1e3)}}scheduleConnect(e){clearTimeout(this.pingSchedule),clearTimeout(this.connectSchedule),this.connectSchedule=setTimeout((()=>{this.ctx.postMessage({topic:"disconnected"}),this.connect()}),e)}handle(e){if(e.v&&void 0!==this.version){if(e.v<=this.version)return void this.debug("already has event "+e.v);e.v>this.version+1&&(this.debug("event gap detected from "+this.version+" to "+e.v),this.ctx.postMessage({topic:"resync"})),this.version=e.v}switch(e.t||!1){case!1:break;case"ack":this.ackable.onServerAck(e.d);break;default:-1!==this.options.registeredEvents.indexOf(e.t)&&this.ctx.postMessage({topic:"handle",payload:e})}}setVersion(e){this.version=e,this.connect()}debug(e,t=!1){t||this.options.debug}delayedDisconnect(e){this.debug(`Will disconnect in ${e}...`),this.delayedDisconnectTimeoutId=setTimeout((()=>{this.disconnect()}),e)}cancelDelayedDisconnect(){clearTimeout(this.delayedDisconnectTimeoutId),this.delayedDisconnectTimeoutId=void 0}deploy(){this.disconnect(),null===this.delayedDisconnectTimeoutId&&this.scheduleConnect(1e4+10*Math.random()*1e3)}pingInterval(){return this.options.pingDelay+this.averageLag}}StrongSocket.defaultOptions={name:"unnamed",idle:!1,pingMaxLag:9e3,pingDelay:2500,autoReconnectDelay:3500,sendOnOpen:void 0,registeredEvents:[],isAuth:!1};class Ackable{constructor(e){this.send=e,this.currentId=1,this.messages=[],this.sign=e=>this._sign=e,this.resend=()=>{const e=performance.now()-2500;this.messages.forEach((t=>{t.at<e&&this.send(t.t,t.d,{sign:this._sign})}))},this.register=(e,t)=>{t.a=this.currentId++,this.messages.push({t:e,d:t,at:performance.now()})},this.onServerAck=e=>{this.messages=this.messages.filter((t=>t.d.a!==e))},setInterval(this.resend,1200)}}let e;const t=self;function s(t){const[s,n,i,o]=t;if(e&&e.ws)if(e.path===s||"noCheck"===s)e.send(n,i,o);else{const t={t:n,d:i,url:s};e.send("wrongHole",t)}}t.onmessage=n=>{switch(n.data.topic){case"create":!function(s){if(e&&"default"===s.opts.options.name&&"default"===e.options.name)return;e?e.disconnect((()=>{e=new StrongSocket(t,s.clientId,s.socketEndPoint,s.url,s.version,s.opts)})):e=new StrongSocket(t,s.clientId,s.socketEndPoint,s.url,s.version,s.opts)}(n.data.payload);break;case"send":s(n.data.payload);break;case"ask":{const t=n.data.payload.listenTo;e&&-1===e.options.registeredEvents.indexOf(t)&&e.options.registeredEvents.push(t),s(n.data.payload.msg);break}case"connect":e&&e.connect();break;case"disconnect":e&&e.disconnect();break;case"delayedDisconnect":e&&e.delayedDisconnect(n.data.payload);break;case"cancelDelayedDisconnect":e&&e.cancelDelayedDisconnect();break;case"destroy":e&&(e.disconnect(),e=void 0);break;case"setVersion":e&&e.setVersion(n.data.payload);break;case"averageLag":e?t.postMessage({topic:"averageLag",payload:Math.round(e.averageLag)}):t.postMessage({topic:"averageLag",payload:null});break;case"getVersion":e?t.postMessage({topic:"getVersion",payload:e.version}):t.postMessage({topic:"getVersion",payload:null});break;case"deploy":e&&e.deploy();break;default:throw new Error("socker worker message not supported: "+n.data.topic)}}}();
